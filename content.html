<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WeConnect - Social</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <!-- PWA Meta Tags -->
  <meta name="theme-color" content="#ffffff">
  <meta name="description" content="WeConnect - Social Feed">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="WeConnect">
  <!-- PWA Manifest & Apple Touch Icons -->
  <link rel="manifest" href="/manifest.json">
  <link rel="apple-touch-icon" href="/icons/icon-192x192.png">
  <!-- Fonts & Icons -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet">
  <!-- Removed Tailwind CDN as custom styles are extensive -->
  <!-- <script src="https://cdn.tailwindcss.com"></script> -->
  <style>
    /* Global Styles & Variables */
    :root {
      --WeConnect-blue: #696ffa;
      --text-dark: #1A1A1A;
      --text-secondary: #65676b;
      --facebook-blue: #1877F2; /* Consider renaming if not Facebook clone */
      --card-background: #ffffff;
      --body-background: #f0f2f5;
      --separator-color: #e0e0e0;
      --input-background: #f0f2f5; /* Changed from #f0f0f0 */
      --icon-color-inactive: var(--text-secondary);
      --icon-color-active: var(--facebook-blue);
      --like-color: #e0245e;
      --header-height: 64px;
      --border-radius-soft: 8px;
      --border-radius-pill: 9999px;
      --transition-speed: 0.2s;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; } /* Add smooth scrolling */
    body {
      font-family: 'Open Sans', sans-serif;
      background-color: var(--body-background);
      color: var(--text-dark);
      -webkit-tap-highlight-color: transparent;
      overflow-x: hidden;
      /* REMOVED padding-top: var(--header-height); */
      /* Applied max-width directly here for simplicity */
      max-width: 24rem; /* Approx 384px */
      margin: 0 auto; /* Center the content */
      position: relative; /* Needed for potential absolute elements inside */
    }
    h1, h2, h3, h4, h5, h6, .heading { font-family: 'Roboto', sans-serif; }

    /* Sticky Header (New Post Bar) */
    .sticky-header {
      background-color: var(--card-background);
      padding: 0.6rem 1rem;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      border-bottom: 1px solid var(--separator-color);
      position: fixed;
      top: 0;
      /* Make header span the container width */
      left: auto;
      right: auto;
      width: 100%;
      max-width: 24rem; /* Match body max-width */
      margin: 0 auto; /* Center header */
      z-index: 50;
      height: var(--header-height);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    .sticky-header .post-avatar { /* Shared style */
      width: 40px;
      height: 40px;
      border-radius: var(--border-radius-pill);
      overflow: hidden;
      flex-shrink: 0;
      background-color: #e5e7eb; /* Placeholder bg */
    }
    .sticky-header .post-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .sticky-header .new-post-input {
      flex: 1;
      background-color: var(--input-background);
      border: 1px solid #ddd; /* Subtle border */
      border-radius: var(--border-radius-pill);
      padding: 0.7rem 1.1rem; /* Slightly adjusted padding */
      font-size: 0.9rem;
      cursor: pointer;
      color: var(--text-secondary); /* Placeholder text color */
      transition: background-color var(--transition-speed) ease, border-color var(--transition-speed) ease;
      text-align: left; /* Align placeholder left */
    }
    .sticky-header .new-post-input:hover {
      background-color: #e9ebee; /* Lighter hover */
      border-color: #ccc;
    }
    .sticky-header .header-action-icons {
      display: flex;
      align-items: center;
      gap: 0.5rem; /* Reduced gap slightly */
    }
    .sticky-header .header-action-icon {
      color: var(--icon-color-inactive);
      font-size: 1.6rem; /* Slightly smaller icons */
      cursor: pointer;
      padding: 0.35rem; /* Adjust padding for hit area */
      border-radius: 50%;
      transition: color var(--transition-speed) ease, background-color var(--transition-speed) ease;
    }
    .sticky-header .header-action-icon:hover {
      color: var(--text-dark);
      background-color: #f0f0f0; /* Subtle background on hover */
    }
    .sticky-header .photo-icon { color: #45bd62; }
    .sticky-header .messenger-icon { color: var(--facebook-blue); } /* Keep branded color */

    /* Main Content Area - ADDED PADDING TOP */
    main {
      padding-top: var(--header-height);
      width: 100%;
      overflow-y: auto; /* Ensure main itself doesn't cause double scrollbars if needed */
      /* REMOVED inline margin-top */
    }

    /* Stories & Reels */
    .stories-reels-tabs {
      background-color: var(--card-background);
      display: flex;
      border-bottom: 1px solid var(--separator-color);
    }
    .tab-button {
      flex: 1;
      padding: 0.9rem 0;
      text-align: center;
      font-weight: 600;
      color: var(--icon-color-inactive);
      cursor: pointer;
      position: relative;
      border-bottom: 3px solid transparent;
      transition: color var(--transition-speed) ease, border-bottom-color var(--transition-speed) ease;
    }
    .tab-button.active {
      color: var(--icon-color-active);
      border-bottom-color: var(--icon-color-active);
    }
    .stories-container {
      background-color: var(--card-background);
      padding: 0.75rem 0.5rem;
      display: flex;
      gap: 0.5rem;
      overflow-x: auto;
      scrollbar-width: none;
      -ms-overflow-style: none;
      /* Removed margin-bottom, combined separation with post-card */
      border-bottom: 6px solid var(--body-background);
    }
    .stories-container::-webkit-scrollbar { display: none; }
    .story-card {
      width: 90px;
      height: 160px;
      flex-shrink: 0;
      border-radius: var(--border-radius-soft); /* Softer radius */
      background-color: #e4e6eb;
      overflow: hidden;
      cursor: pointer;
      position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,0.1);
      border: 1px solid rgba(0, 0, 0, 0.05);
      transition: transform var(--transition-speed) ease-in-out; /* Added transition */
    }
    .story-card:hover { transform: scale(1.03); } /* Subtle hover scale */
    .story-card .story-avatar {
      position: absolute;
      top: 8px;
      left: 8px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 3px solid var(--facebook-blue); /* Slightly thicker border */
      overflow: hidden;
      z-index: 3;
    }
    .story-card .story-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .story-card .story-author-name {
      position: absolute;
      bottom: 8px;
      left: 8px;
      right: 8px;
      color: white;
      font-size: 0.75rem;
      font-weight: 600;
      text-shadow: 0 1px 3px rgba(0,0,0,0.7); /* Stronger shadow */
      z-index: 3;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .story-card::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 50%;
      background: linear-gradient(to top, rgba(0,0,0,0.6), transparent); /* Darker gradient */
      z-index: 2;
      pointer-events: none;
    }
    .story-card img.story-bg {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      transition: transform 0.3s ease-in-out; /* Slower BG transition */
    }
    .story-card:hover img.story-bg { transform: scale(1.05); }
    /* Create Story Card Specifics */
    .create-story-card {
      background-color: var(--card-background);
      display: flex;
      flex-direction: column;
    }
    .create-story-card img.user-avatar {
      width: 100%;
      height: 100px; /* Adjust height as needed */
      object-fit: cover;
      border-bottom: 1px solid var(--separator-color);
    }
    .create-story-content {
      flex-grow: 1;
      position: relative;
      display: flex;
      justify-content: center;
      background-color: var(--card-background); /* Ensure bg matches */
    }
    .create-story-icon-wrapper {
      position: absolute;
      top: -18px; /* Position relative to the content area */
      left: 50%;
      transform: translateX(-50%);
      width: 36px;
      height: 36px;
      background-color: var(--facebook-blue);
      border-radius: 50%;
      border: 4px solid var(--card-background); /* Border blends with card */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }
    .create-story-icon {
      color: white;
      font-size: 22px;
      font-weight: bold;
      line-height: 1; /* Ensure centering */
    }
    .create-story-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-secondary); /* Use secondary text color */
      text-align: center;
      padding-top: 22px; /* Space for the icon */
      padding-bottom: 5px;
    }

    /* Post Feed */
    .post-list {
      display: flex;
      flex-direction: column;
      gap: 0; /* Reset gap */
      padding: 0;
    }
    .post-card {
      background-color: var(--card-background);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      border-bottom: 6px solid var(--body-background); /* Separator */
      margin-bottom: 0; /* Reset margin */
      position: relative;
      box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Subtle shadow */
    }
    .post-header {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.75rem 1rem;
    }
    .post-avatar { /* Shared style */
      width: 40px;
      height: 40px;
      border-radius: var(--border-radius-pill);
      background-color: #ccc; /* Placeholder bg */
      overflow: hidden;
      flex-shrink: 0;
    }
    .post-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .post-info {
      display: flex;
      flex-direction: column;
      font-size: 0.85rem;
      line-height: 1.3; /* Adjust line height */
    }
    .post-author {
      font-weight: 600;
      color: #050505; /* Slightly off-black */
    }
    .post-time {
      font-size: 0.75rem;
      color: var(--icon-color-inactive);
    }
    .post-content {
      padding: 0.25rem 1rem 0.75rem 1rem;
      font-size: 0.9rem;
      line-height: 1.45; /* Increased line height for readability */
      color: #1c1e21; /* Slightly different text color */
      word-wrap: break-word; /* Keep this */
    }
    .post-media {
      max-height: 500px; /* Keep max height */
      overflow: hidden;
      background-color: #000; /* Black background for media */
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .post-media img, .post-media video {
      width: 100%;
      height: auto;
      max-height: 500px; /* Match container */
      object-fit: contain; /* Use contain to avoid cropping */
      display: block; /* Remove extra space below */
    }
    .post-stats {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.6rem 1rem; /* Adjusted padding */
      font-size: 0.8rem;
      color: var(--icon-color-inactive);
      border-bottom: 1px solid var(--separator-color);
    }
    .post-stats .likes-count, .post-stats .comments-count {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    /* Style for the like icon within stats */
    .post-stats .likes-count .material-icons {
        font-size: 0.9rem; /* Smaller icon */
        color: var(--icon-color-inactive); /* Default color */
        margin-right: 2px; /* Space between icon and number */
    }
    .post-stats .likes-count .like-icon-filled {
      color: var(--facebook-blue); /* Or use like-color if preferred */
    }
    .post-actions {
      display: flex;
      justify-content: space-around;
      padding: 0.1rem 0; /* Reduced padding */
      border-bottom: 1px solid var(--separator-color);
    }
    .action-button {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.4rem;
      padding: 0.6rem 0; /* Adjusted padding */
      cursor: pointer;
      border-radius: var(--border-radius-soft); /* Softer radius */
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease; /* Add color transition */
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--icon-color-inactive);
      background: none;
      border: none;
    }
    .action-button:hover { background-color: var(--input-background); }
    .action-button .material-icons, .action-button .material-icons-outlined {
      font-size: 1.25rem; /* Keep icon size */
    }
    .action-button.liked .material-icons { color: var(--like-color); } /* Use specific like color */
    .action-button.liked { color: var(--like-color); }

    /* Comments Section - ADDED TRANSITIONS */
    .comments-section {
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      /* Transition properties */
      transition: max-height 0.3s ease-out, opacity 0.3s ease-out, padding 0.3s ease-out;
      max-height: 0; /* Start collapsed */
      opacity: 0;
      overflow: hidden;
      padding-top: 0; /* No top padding when hidden */
      padding-bottom: 0; /* No bottom padding when hidden */
    }
    .comments-section.visible {
       /* padding: 0.5rem 1rem; /* Restore padding */
       /* max-height needs to be set dynamically in JS */
       opacity: 1;
    }
    .comments-list { /* Container for actual comments */
        /* Styles for individual comments handled by .comment */
    }
    .comment {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }
    .comment-avatar { /* Shared style */
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }
    .comment-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    .comment-content {
      background-color: var(--input-background);
      padding: 0.5rem 0.75rem;
      border-radius: 15px; /* Keep bubble radius */
      flex-grow: 1;
    }
    .comment-author {
      font-weight: 600;
      color: #050505;
      font-size: 0.8rem;
      margin-bottom: 0.1rem;
    }
    .comment-text {
      color: #1c1e21; /* Match post text color */
      word-wrap: break-word;
      line-height: 1.35;
    }
    .comment-time {
      font-size: 0.7rem;
      color: var(--icon-color-inactive);
      margin-top: 0.2rem;
    }
    .comment-input-area {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem 0.75rem 1rem;
      /* border-top: 1px solid var(--separator-color); */ /* Optional separator */
    }
    /* Using .post-avatar for consistency, maybe rename class later */
    .comment-input-area .post-avatar {
        width: 32px;
        height: 32px;
    }
    .comment-input {
      flex-grow: 1;
      background-color: var(--input-background);
      border: 1px solid #ddd; /* Match header input */
      border-radius: var(--border-radius-pill);
      padding: 0.5rem 1rem;
      font-size: 0.9rem;
      outline: none;
      transition: border-color var(--transition-speed) ease;
    }
    .comment-input:focus {
        border-color: var(--facebook-blue); /* Highlight on focus */
    }
    .comment-submit-btn {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--facebook-blue);
      font-size: 1.5rem;
      padding: 0;
      line-height: 1;
      transition: color var(--transition-speed) ease;
    }
    .comment-submit-btn.disabled {
      color: var(--icon-color-inactive);
      cursor: default;
    }

    /* Loading overlay */
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255, 255, 255, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }
    .loading-spinner {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      border: 3px solid rgba(105, 111, 250, 0.2);
      border-top-color: var(--WeConnect-blue);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 3rem 1rem; /* More padding */
      color: var(--text-secondary);
      display: none; /* Hidden by default */
      margin-top: 2rem;
      background-color: var(--card-background); /* Give it a background */
      border-radius: var(--border-radius-soft);
      box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    .empty-state i {
      font-size: 3rem;
      color: #ddd;
      margin-bottom: 1rem;
    }
    .empty-state h3 { font-size: 1.2rem; margin-bottom: 0.5rem; color: var(--text-dark); }
    .empty-state p { font-size: 0.9rem; } /* Smaller text */

    /* Modal Styling - MODERNIZED */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6); /* Darker overlay */
      display: none; /* Hidden by default */
      justify-content: center;
      align-items: center;
      z-index: 1100;
      opacity: 0;
      transition: opacity var(--transition-speed) ease;
    }
    .modal-overlay.active {
       display: flex;
       opacity: 1;
    }
    .modal-content {
      background-color: var(--card-background);
      border-radius: var(--border-radius-soft); /* Softer radius */
      width: 90%;
      max-width: 400px;
      padding: 0; /* Remove padding, handle internally */
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      position: relative;
      overflow: hidden; /* Needed for internal padding */
    }
    .modal-header {
      font-size: 1.2rem; /* Slightly smaller */
      font-weight: 600; /* Bolder */
      padding: 1rem 1.25rem; /* Header padding */
      border-bottom: 1px solid var(--separator-color);
      text-align: center;
      position: relative; /* For close button positioning */
       display: flex; /* To align items */
       align-items: center; /* Center items vertically */
       gap: 0.75rem; /* Space between avatar and title */
    }
     /* Avatar within modal header */
    .modal-header .modal-user-avatar {
        width: 32px;
        height: 32px;
        border-radius: 50%;
        overflow: hidden;
        flex-shrink: 0;
    }
    .modal-header .modal-user-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }
     .modal-header .modal-title {
        flex-grow: 1; /* Allow title to take space */
        text-align: center; /* Center title text */
        margin-left: -32px; /* Offset the avatar space to truly center title */
        padding-right: 32px; /* Prevent overlap with close button */
    }
    .modal-close {
      position: absolute;
      top: 50%; /* Center vertically in header */
      right: 10px;
      transform: translateY(-50%);
      cursor: pointer;
      font-size: 1.8rem; /* Larger close icon */
      color: var(--icon-color-inactive);
      line-height: 1;
      padding: 5px; /* Hit area */
      border-radius: 50%;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
    }
    .modal-close:hover {
        color: var(--text-dark);
        background-color: #f0f0f0;
    }
    .modal-body {
        padding: 1rem 1.25rem; /* Body padding */
    }
    .modal-input, .modal-textarea {
      width: 100%;
      padding: 0.7rem 0.9rem; /* Adjusted padding */
      margin-bottom: 1rem; /* Consistent margin */
      border: 1px solid #ccc; /* Clearer border */
      border-radius: var(--border-radius-soft); /* Use soft radius */
      font-size: 0.95rem;
      background-color: #fff; /* White background */
      transition: border-color var(--transition-speed) ease;
    }
     .modal-textarea {
        min-height: 80px; /* Minimum height */
        resize: vertical; /* Allow vertical resize */
     }
    .modal-input:focus, .modal-textarea:focus {
      border-color: var(--facebook-blue);
      outline: none; /* Remove default outline */
    }
    .modal-button {
      width: 100%;
      padding: 0.75rem 1rem; /* Adjusted padding */
      background-color: var(--facebook-blue);
      color: white;
      border: none;
      border-radius: var(--border-radius-soft);
      cursor: pointer;
      font-size: 1rem;
      font-weight: 600;
      transition: background-color var(--transition-speed) ease;
      display: flex; /* For potential icon */
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }
    .modal-button:hover { background-color: #166fe5; }
    .modal-button:disabled {
        background-color: #a0c3f0; /* Disabled look */
        cursor: not-allowed;
    }

    /* Post Owner Actions */
    .post-owner-actions {
      margin-left: auto; /* Pushes to the right */
      display: flex;
      align-items: center; /* Align vertically */
      gap: 0.25rem; /* Smaller gap */
    }
    .post-owner-actions button {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--icon-color-inactive); /* Use inactive color */
      font-size: 1.2rem; /* Use icon size */
      padding: 0.35rem; /* Hit area */
      border-radius: 50%;
      line-height: 1;
      transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
    }
     .post-owner-actions button:hover {
        background-color: #f0f0f0;
        color: var(--text-dark);
     }
     /* Use icons instead of text */
     .post-owner-actions .edit-icon::before { content: 'edit'; font-family: 'Material Icons Outlined'; }
     .post-owner-actions .delete-icon::before { content: 'delete_outline'; font-family: 'Material Icons Outlined'; }

    /* Notification Banner */
    .notification-banner {
      position: fixed;
      top: calc(var(--header-height) + 10px); /* Position below header */
      left: 50%;
      transform: translateX(-50%); /* Center horizontally */
      background-color: rgba(0, 0, 0, 0.8); /* Darker, semi-transparent */
      color: #fff;
      padding: 0.7rem 1.2rem;
      border-radius: var(--border-radius-pill); /* Pill shape */
      z-index: 1200;
      opacity: 0;
      transition: opacity 0.5s ease, top 0.5s ease; /* Add top transition */
      font-size: 0.85rem;
      pointer-events: none; /* Prevent interaction */
    }
    .notification-banner.show {
        opacity: 1;
        top: calc(var(--header-height) + 15px); /* Slide down slightly */
        pointer-events: auto;
    }
  </style>
  <script>
    // Prevent excessive zoom/tap events (Keep as is)
    document.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    document.addEventListener('touchmove', e => { if (e.touches.length > 1) e.preventDefault(); }, { passive: false });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  </script>
</head>
<!-- Removed max-w-sm mx-auto from body tag, handled in CSS -->
<body>
  <!-- Loading Overlay -->
  <div id="loadingOverlay" class="loading-overlay active">
    <div class="loading-spinner"></div>
  </div>

  <!-- Notification Banner -->
  <div id="notificationBanner" class="notification-banner"></div>

  <!-- Sticky Header (New Post Bar) -->
  <div class="sticky-header">
    <div class="post-avatar">
      <a href="user-profile.html?uid=" id="newPostUserAvatarLink">
        <img src="assets/images/user.png" alt="User Avatar" id="newPostUserAvatar" />
      </a>
    </div>
    <!-- Changed placeholder text -->
    <div id="showNewPostModal" class="new-post-input">What's on your mind?</div>
    <div class="header-action-icons">
       <!-- Make photo icon also trigger modal -->
      <span class="material-icons header-action-icon photo-icon" id="showNewPostModalPhoto">photo_library</span>
      <span class="material-icons header-action-icon messenger-icon" onclick="handleMessageClick()">email</span>
    </div>
  </div>

  <!-- Main Content Area -->
  <!-- Removed inline style -->
  <main class="flex-1 w-full">
    <!-- Stories & Reels Tabs -->
    <div class="stories-reels-tabs">
      <div class="tab-button active">Connects</div>
      <div class="tab-button">Feels</div>
    </div>
    <!-- Stories Container -->
    <div class="stories-container" id="storiesContainer">
      <!-- Create Connect Card -->
      <div class="story-card create-story-card" id="createConnectCard">
        <a href="user-profile.html?uid=" id="createConnectUserAvatarLink">
          <img class="user-avatar" src="assets/images/user.png" alt="Your Avatar" id="createConnectUserAvatar">
        </a>
        <div class="create-story-content">
          <div class="create-story-icon-wrapper"><span class="create-story-icon">+</span></div>
          <div class="create-story-label">Create connects</div>
        </div>
      </div>
      <!-- Additional connects loaded dynamically -->
    </div>
    <!-- Hidden File Input for Connects -->
    <input type="file" id="connectFileInput" accept="image/*" style="display: none;">

    <!-- Post Feed -->
    <div id="postList" class="post-list">
      <!-- Posts loaded dynamically -->
    </div>
    <div class="empty-state" id="emptyState">
      <i class="material-icons">feed</i>
      <h3>No posts yet</h3>
      <p>Start connecting with others!</p>
    </div>
  </main>

  <!-- New Post Modal -->
  <div id="newPostModal" class="modal-overlay">
    <div class="modal-content">
       <div class="modal-header">
         <!-- Added Avatar to Modal -->
         <div class="modal-user-avatar">
             <img src="assets/images/user.png" alt="User Avatar" id="modalUserAvatar" />
         </div>
         <span class="modal-title">Create Post</span>
         <span id="modalClose" class="modal-close">×</span>
       </div>
       <div class="modal-body">
         <textarea id="postDescription" class="modal-textarea" rows="4" placeholder="What's on your mind?"></textarea>
         <label for="postMedia" class="modal-button" style="background-color: #e4e6eb; color: #4b4f56; margin-bottom: 1rem;">
             <span class="material-icons-outlined" style="color: #45bd62;">add_photo_alternate</span> Add Photo/Video
         </label>
         <input id="postMedia" type="file" class="modal-input" accept="image/*,video/*" style="display: none;"/>
         <button id="submitPost" class="modal-button">Post</button>
       </div>
    </div>
  </div>

  <!-- Edit Post Modal -->
  <div id="editPostModal" class="modal-overlay">
    <div class="modal-content">
       <div class="modal-header">
          <!-- Added Avatar to Edit Modal too -->
         <div class="modal-user-avatar">
             <img src="assets/images/user.png" alt="User Avatar" id="editModalUserAvatar" />
         </div>
         <span class="modal-title">Edit Post</span>
         <span id="editModalClose" class="modal-close">×</span>
       </div>
       <div class="modal-body">
          <textarea id="editPostDescription" class="modal-textarea" rows="4" placeholder="Edit your post"></textarea>
          <button id="updatePost" class="modal-button">Update</button>
       </div>
    </div>
  </div>

  <!-- Firebase & App Scripts -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-app.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-auth.js";
    import { getFirestore, collection, getDocs, getDoc, addDoc, updateDoc, deleteDoc, serverTimestamp, query, orderBy, where, limit, doc, onSnapshot, runTransaction } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-firestore.js";
    import { getStorage, ref as storageRef, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.21.0/firebase-storage.js";

    // --- Firebase Config (Keep Yours) ---
    const firebaseConfig = {
  apiKey: "AIzaSyDwldURmtljNpORmpGRacwXriPmQZjF6j8",
  authDomain: "daisy-n7g20a.firebaseapp.com",
  databaseURL: "https://daisy-n7g20a-default-rtdb.firebaseio.com",
  projectId: "daisy-n7g20a",
  storageBucket: "daisy-n7g20a.appspot.com",
  messagingSenderId: "225362605902",
  appId: "1:225362605902:web:d2551cc389e78c92c3d01f"
};
    let app, auth, db, storage;
    try {
      app = initializeApp(firebaseConfig);
      auth = getAuth(app);
      db = getFirestore(app);
      storage = getStorage(app);
      console.log("Firebase Initialized Successfully for Social Page");
    } catch (error) {
      console.error("Firebase Initialization Failed:", error);
      document.getElementById("loadingOverlay")?.classList.remove("active");
    }

    // --- DOM Element References ---
    const loadingOverlay = document.getElementById("loadingOverlay");
    const postList = document.getElementById("postList");
    const emptyState = document.getElementById("emptyState");
    const showNewPostModalBtn = document.getElementById("showNewPostModal");
    const showNewPostModalPhotoBtn = document.getElementById("showNewPostModalPhoto");
    const newPostModal = document.getElementById("newPostModal");
    const modalClose = document.getElementById("modalClose");
    const submitPostBtn = document.getElementById("submitPost");
    const editPostModal = document.getElementById("editPostModal");
    const editModalClose = document.getElementById("editModalClose");
    const updatePostBtn = document.getElementById("updatePost");
    const postDescriptionEl = document.getElementById("postDescription");
    const postMediaEl = document.getElementById("postMedia");
    const editPostDescriptionEl = document.getElementById("editPostDescription");
    const connectFileInput = document.getElementById("connectFileInput");
    const storiesContainer = document.getElementById("storiesContainer");
    const createConnectCard = document.getElementById("createConnectCard");
    const notificationBanner = document.getElementById("notificationBanner");
    const newPostUserAvatar = document.getElementById("newPostUserAvatar");
    const newPostUserAvatarLink = document.getElementById("newPostUserAvatarLink");
    const createConnectUserAvatar = document.getElementById("createConnectUserAvatar");
    const createConnectUserAvatarLink = document.getElementById("createConnectUserAvatarLink");
    // Modal Avatars
    const modalUserAvatar = document.getElementById("modalUserAvatar");
    const editModalUserAvatar = document.getElementById("editModalUserAvatar");


    let currentUser = null;
    let userLikes = {}; // Cache user's likes { postId: true }
    let postsDataGlobal = {}; // Cache post data { postId: data }
    let editPostId = null; // Track which post is being edited

    // --- Helper Functions ---

    function showNotification(message) {
      if (!notificationBanner) return;
      notificationBanner.textContent = message;
      notificationBanner.classList.add("show");
      // Auto-hide after 3 seconds
      setTimeout(() => {
        notificationBanner.classList.remove("show");
      }, 3000);
    }

    // Update user avatars in header and modals
    function updateHeaderAvatars(user) {
      const avatarUrl = user?.photoURL || 'assets/images/user.png'; // Fallback image
      const profileLink = `user-profile.html?uid=${user ? user.uid : ''}`;

      if (newPostUserAvatar) newPostUserAvatar.src = avatarUrl;
      if (newPostUserAvatarLink) newPostUserAvatarLink.href = profileLink;

      if (createConnectUserAvatar) createConnectUserAvatar.src = avatarUrl;
      if (createConnectUserAvatarLink) createConnectUserAvatarLink.href = profileLink;

      // Update modal avatars
      if (modalUserAvatar) modalUserAvatar.src = avatarUrl;
      if (editModalUserAvatar) editModalUserAvatar.src = avatarUrl;
    }

    function showEmptyState(message = "No posts yet", subMessage = "Start connecting with others!") {
      if (postList) postList.innerHTML = ""; // Clear list
      if (emptyState) {
        emptyState.style.display = 'block';
        emptyState.querySelector('h3').textContent = message;
        emptyState.querySelector('p').textContent = subMessage;
      }
    }

    function hideEmptyState() {
        if (emptyState) emptyState.style.display = 'none';
    }

    function formatTimestamp(timestamp) {
        if (!timestamp) return "";
        const date = timestamp.toDate(); // Convert Firestore Timestamp to Date
        const now = new Date();
        const secondsPast = (now.getTime() - date.getTime()) / 1000;

        if (secondsPast < 5) return 'Just now';
        if (secondsPast < 60) return `${Math.round(secondsPast)}s ago`;
        if (secondsPast < 3600) return `${Math.round(secondsPast / 60)}m ago`;
        if (secondsPast < 86400) return `${Math.round(secondsPast / 3600)}h ago`;
        if (secondsPast < 604800) return `${Math.round(secondsPast / 86400)}d ago`;

        // Older than a week: show date
        const options = { month: 'short', day: 'numeric' };
        if (date.getFullYear() !== now.getFullYear()) {
            options.year = 'numeric';
        }
        return date.toLocaleDateString(undefined, options);
    }

    // Basic link/newline formatting
    function formatPostContent(text) {
      if (!text) return '';
      // Escape HTML to prevent XSS
      const escapedText = text.replace(/</g, "<").replace(/>/g, ">");
      // Convert URLs to links
      const linkedText = escapedText.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer" style="color: var(--facebook-blue); text-decoration: underline;">$1</a>');
      // Convert newlines to <br>
      return linkedText.replace(/\n/g, '<br>');
    }

    // --- Firebase Operations ---

    // Load Connects (Stories)
    async function loadConnects() {
      if (!db || !currentUser || !storiesContainer) return;
      const connectsRef = collection(db, "connects");
      // Optional: Add time limit (e.g., last 24 hours)
      // const yesterday = new Date();
      // yesterday.setDate(yesterday.getDate() - 1);
      // const q = query(connectsRef, where("createdAt", ">=", yesterday), orderBy("createdAt", "desc"));
      const q = query(connectsRef, orderBy("createdAt", "desc"), limit(15)); // Load recent connects
      try {
        const snapshot = await getDocs(q);
        const connectsData = snapshot.docs.map(docSnap => ({ id: docSnap.id, ...docSnap.data() }));
        renderConnects(connectsData);
      } catch (error) { console.error("Error loading connects:", error); }
    }

    function clearConnects() {
        if (!storiesContainer) return;
        // Remove only dynamic connects, keep the "Create" card
        const existingConnects = storiesContainer.querySelectorAll('.story-card:not(.create-story-card)');
        existingConnects.forEach(card => card.remove());
    }

    function renderConnects(connects) {
      if (!storiesContainer) return;
      clearConnects(); // Clear previous dynamic connects
      connects.forEach(connect => {
        const connectCard = document.createElement('div');
        connectCard.className = 'story-card';
        connectCard.dataset.connectId = connect.id;
        connectCard.innerHTML = `
          <div class="story-avatar">
            <a href="user-profile.html?uid=${connect.authorId || ''}">
              <img src="${connect.authorAvatarUrl || 'assets/images/user.png'}" alt="${connect.authorName || 'User'}">
            </a>
          </div>
          <img class="story-bg" src="${connect.imageUrl}" alt="Connect by ${connect.authorName || 'User'}">
          <div class="story-author-name">${connect.authorName || 'Anonymous'}</div>
        `;
        connectCard.addEventListener('click', () => {
          // Add logic to view the connect (e.g., open a modal)
          showNotification(`Viewing connect from ${connect.authorName || 'Anonymous'}`);
        });
        // Insert after the "Create" card
        createConnectCard.insertAdjacentElement('afterend', connectCard);
      });
       // Reverse the order they were added to show newest first (leftmost after create card)
       const dynamicConnects = Array.from(storiesContainer.querySelectorAll('.story-card:not(.create-story-card)'));
       dynamicConnects.reverse().forEach(card => storiesContainer.appendChild(card));
    }

    // Create Connect (Story)
    async function createConnect(file) {
        if (!file || !currentUser || !storage || !db) {
            if (!currentUser) showNotification("Please log in to create a connect.");
            return;
        }
        loadingOverlay?.classList.add('active');
        if (createConnectCard) { // Visual feedback
             createConnectCard.style.opacity = '0.5';
             createConnectCard.style.pointerEvents = 'none';
        }

        try {
            const filePath = `connects/${currentUser.uid}/${Date.now()}_${file.name}`;
            const fileRef = storageRef(storage, filePath);
            const uploadSnapshot = await uploadBytes(fileRef, file);
            const imageUrl = await getDownloadURL(uploadSnapshot.ref);

            const connectsRef = collection(db, "connects");
            await addDoc(connectsRef, {
                imageUrl: imageUrl,
                authorId: currentUser.uid,
                authorName: currentUser.displayName || currentUser.email || "Anonymous",
                authorAvatarUrl: currentUser.photoURL || 'assets/images/user.png', // Ensure fallback
                createdAt: serverTimestamp()
            });
            await loadConnects(); // Reload connects
            showNotification("Connect created successfully!");
        } catch (error) {
            console.error("Error creating connect:", error);
            showNotification(`Failed to create connect: ${error.message}`);
        } finally {
            loadingOverlay?.classList.remove("active");
             if (createConnectCard) { // Restore card state
                 createConnectCard.style.opacity = '1';
                 createConnectCard.style.pointerEvents = 'auto';
             }
            if (connectFileInput) connectFileInput.value = ''; // Reset file input
        }
    }


    // Load Posts
    async function loadPosts() {
      if (!db) return; // Don't run if DB not ready
      // Don't require login to view posts, but likes/comments will be disabled
      // if (!currentUser) { showEmptyState("Log in to see feed"); return; }

      try {
        const postsRef = collection(db, "social");
        const q = query(postsRef, orderBy("createdAt", "desc"), limit(20)); // Load more posts initially
        const snapshot = await getDocs(q);

        let postsData = [];
        snapshot.forEach(docSnap => {
          const data = docSnap.data();
          postsData.push({ id: docSnap.id, ...data });
          postsDataGlobal[docSnap.id] = data; // Update global cache
        });

        if (currentUser) {
             // Fetch likes only if user is logged in
            await fetchUserLikesForPosts(postsData.map(p => p.id));
        } else {
            userLikes = {}; // Clear likes if logged out
        }


        if (postsData.length === 0) {
          showEmptyState();
        } else {
          renderPosts(postsData);
          hideEmptyState();
        }
      } catch (error) {
        console.error("Error loading posts:", error);
        showEmptyState("Error loading posts.", "Please try again later.");
      } finally {
        // Ensure loading overlay is hidden even if there's an error during load
        // (Wait a tiny bit for rendering)
        setTimeout(() => loadingOverlay?.classList.remove("active"), 100);
      }
    }

    // Fetch which posts the current user has liked
    async function fetchUserLikesForPosts(postIds) {
      if (!currentUser || postIds.length === 0 || !db) return;
      // Reset likes for the current batch
      // userLikes = {}; // Don't reset fully if loading more later

      const likePromises = postIds.map(postId => {
          if (userLikes[postId] === undefined) { // Only fetch if not already cached
              const likeRef = doc(db, "social", postId, "likes", currentUser.uid);
              return getDoc(likeRef).then(likeSnap => ({ postId, exists: likeSnap.exists() }));
          }
          return Promise.resolve(null); // Skip already known likes
      });

      try {
        const results = await Promise.all(likePromises);
        results.forEach(result => {
            if (result) { // If the promise wasn't skipped
                userLikes[result.postId] = result.exists; // Store boolean
            }
        });
      } catch (error) {
        console.error("Error fetching user likes:", error);
        // Handle error, maybe retry or show a message
      }
    }

    // Render all posts
    function renderPosts(posts) {
      if (!postList) return;
      postList.innerHTML = ""; // Clear existing posts before rendering new batch
      posts.forEach(post => {
        const postEl = createPostElement(post);
        postList.appendChild(postEl);
      });
      // Add listeners after posts are in the DOM (using event delegation is better)
      // Listeners are added globally to postList now, so no need here.
    }

    // Create HTML for a single post
    function createPostElement(post) {
      const postEl = document.createElement("div");
      postEl.className = "post-card";
      postEl.dataset.postId = post.id;

      // Check if current user liked this post (use cached info)
      const hasLiked = currentUser ? (userLikes[post.id] === true) : false;
      const likeCount = post.likeCount || 0;
      const commentCount = post.commentCount || 0;
      const postTimestamp = post.createdAt; // Keep as Firestore Timestamp for formatTimestamp
      const commentAvatarUrl = currentUser?.photoURL || 'assets/images/user.png'; // Current user's avatar for comment input

      // Avatar HTML with link
      const avatarHtml = `
        <div class="post-avatar">
          <a href="user-profile.html?uid=${post.authorId || ''}">
            <img src="${post.authorAvatarUrl || 'assets/images/user.png'}" alt="${post.author || 'Author'} Avatar" />
          </a>
        </div>
      `;

      // Edit/Delete buttons if current user is the author
      let ownerActionsHtml = "";
      if (currentUser && post.authorId === currentUser.uid) {
        ownerActionsHtml = `
          <div class="post-owner-actions">
             <button class="edit-icon" title="Edit Post" onclick="editPost('${post.id}')"></button>
             <button class="delete-icon" title="Delete Post" onclick="deletePost('${post.id}')"></button>
          </div>
        `;
      }

      // Like count display with icon
      const likesDisplayHtml = likeCount > 0
          ? `<span class="material-icons like-icon-filled">thumb_up</span> ${likeCount}`
          : ''; // Empty if no likes

      // Comments count display
      const commentsDisplayHtml = commentCount > 0
          ? `${commentCount} Comment${commentCount > 1 ? 's' : ''}`
          : ''; // Empty if no comments

      postEl.innerHTML = `
        <div class="post-header">
          ${avatarHtml}
          <div class="post-info">
            <a href="user-profile.html?uid=${post.authorId || ''}" style="text-decoration: none; color: inherit;">
                <div class="post-author">${post.author || "Anonymous"}</div>
            </a>
            <div class="post-time">${formatTimestamp(postTimestamp)}</div>
          </div>
          ${ownerActionsHtml}
        </div>
        ${post.description ? `<div class="post-content">${formatPostContent(post.description)}</div>` : ''}
        ${post.mediaUrl ? `<div class="post-media">${post.mediaType === 'video' ? `<video src="${post.mediaUrl}" controls preload="metadata" style="max-width: 100%; height: auto; display: block;"></video>` : `<img src="${post.mediaUrl}" alt="Post Media" />`}</div>` : ''}
        <div class="post-stats">
          <span class="likes-count">${likesDisplayHtml}</span>
          <span class="comments-count">${commentsDisplayHtml}</span>
        </div>
        <div class="post-actions">
          <button class="action-button like-button ${hasLiked ? 'liked' : ''}" data-post-id="${post.id}">
            <span class="material-icons${hasLiked ? '' : '-outlined'}">${hasLiked ? 'thumb_up' : 'thumb_up_off_alt'}</span>
            <span>Like</span>
          </button>
          <button class="action-button comment-button" data-post-id="${post.id}">
            <span class="material-icons-outlined">chat_bubble_outline</span>
            <span>Comment</span>
          </button>
          <!-- Add Share button later if needed -->
        </div>
        <div class="comments-section" data-post-id="${post.id}">
           <!-- Comments will be loaded here -->
           <div class="comments-list">
              <!-- Spinner/placeholder shown while loading -->
              <div style="text-align:center; padding:10px;">
                 <div class="loading-spinner comment-spinner" style="width:20px; height:20px; border-width: 2px; display:none;"></div>
              </div>
           </div>
        </div>
        ${currentUser ? `
        <div class="comment-input-area">
          <div class="post-avatar comment-avatar">
             <a href="user-profile.html?uid=${currentUser.uid || ''}">
               <img src="${commentAvatarUrl}" alt="Your Avatar">
             </a>
          </div>
          <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}" aria-label="Write a comment">
          <button class="comment-submit-btn disabled" data-post-id="${post.id}" aria-label="Send Comment"><span class="material-icons">send</span></button>
        </div>
        ` : '' /* Don't show comment input if not logged in */ }
      `;

      // Add event listener for the comment button *on this specific post*
      const commentButton = postEl.querySelector('.comment-button');
      const commentsSection = postEl.querySelector('.comments-section');
      if (commentButton && commentsSection) {
        commentButton.addEventListener('click', () => toggleComments(post.id, commentsSection));
      }

      return postEl;
    }

    // Toggle Comments Visibility
    function toggleComments(postId, commentsSection) {
        const commentsList = commentsSection.querySelector('.comments-list');
        const isVisible = commentsSection.classList.contains('visible');

        if (!isVisible) {
            commentsSection.classList.add('visible');
            // Set max-height dynamically based on content
            // Needs to be done *after* content is potentially loaded
            commentsSection.style.maxHeight = '500px'; // Set a temporary large max-height
             // Check if comments need loading
             if (!commentsList.dataset.loaded) {
                 loadCommentsForPost(postId, commentsList, commentsSection);
             } else {
                 // If already loaded, just set max-height
                 commentsSection.style.maxHeight = commentsList.scrollHeight + 'px';
             }
            const inputField = postList.querySelector(`.comment-input[data-post-id="${postId}"]`);
            if (inputField) inputField.focus();
        } else {
            commentsSection.classList.remove('visible');
            commentsSection.style.maxHeight = '0';
        }
    }


    // Load comments for a specific post
    async function loadCommentsForPost(postId, commentsContainer, commentsSectionElement) {
        if (!db) return;
        const spinner = commentsContainer.querySelector('.comment-spinner');
        if (spinner) spinner.style.display = 'inline-block';

        try {
            const commentsRef = collection(doc(db, "social", postId), "comments");
            // Load more comments, e.g., 5 most recent
            const q = query(commentsRef, orderBy("createdAt", "desc"), limit(5));
            const snapshot = await getDocs(q);

            // Clear only the spinner/placeholder, not necessarily all previous comments if implementing "load more" later
            commentsContainer.innerHTML = '';

            if (snapshot.empty) {
                commentsContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.8rem; text-align:center; padding: 10px 0;">No comments yet.</p>';
            } else {
                // Render comments (newest first is default from query)
                 snapshot.docs.forEach(docSnap => {
                    renderComment(docSnap.data(), commentsContainer); // Append newest first
                 });
                 // If using desc, reverse before rendering or append and then use flex-direction: column-reverse
                // snapshot.docs.reverse().forEach(docSnap => {
                //    renderComment(docSnap.data(), commentsContainer);
                // });
            }
            commentsContainer.dataset.loaded = "true"; // Mark as loaded

             // Adjust max-height after loading
            if (commentsSectionElement && commentsSectionElement.classList.contains('visible')) {
                 commentsSectionElement.style.maxHeight = commentsContainer.scrollHeight + 'px';
            }

        } catch (error) {
            console.error(`Error loading comments for post ${postId}:`, error);
            commentsContainer.innerHTML = '<p style="color: red; font-size: 0.8rem; text-align: center;">Could not load comments.</p>';
        } finally {
             if (spinner) spinner.style.display = 'none'; // Hide spinner regardless of outcome
        }
    }

    // Render a single comment
    function renderComment(commentData, container) {
        const commentEl = document.createElement('div');
        commentEl.className = 'comment';
        const commentTimestamp = commentData.createdAt; // Keep as Firestore Timestamp

        commentEl.innerHTML = `
            <div class="comment-avatar">
              <a href="user-profile.html?uid=${commentData.authorId || ''}">
                <img src="${commentData.authorAvatarUrl || 'assets/images/user.png'}" alt="${commentData.authorName || 'User'} Avatar">
              </a>
            </div>
            <div class="comment-content">
              <a href="user-profile.html?uid=${commentData.authorId || ''}" style="text-decoration: none; color: inherit;">
                 <div class="comment-author">${commentData.authorName || 'Anonymous'}</div>
              </a>
              <div class="comment-text">${formatPostContent(commentData.text)}</div>
              <div class="comment-time">${formatTimestamp(commentTimestamp)}</div>
            </div>
        `;
        // Prepend to show newest comments at the top easily
        container.prepend(commentEl);
    }

    // Upload Media (Generic for Posts/Connects)
    async function uploadMediaToFirebase(file, pathPrefix = 'posts') {
        if (!storage || !currentUser) {
             showNotification("Cannot upload media. Login required or storage unavailable.");
             return null;
        }
        try {
            const fileRef = storageRef(storage, `${pathPrefix}/${currentUser.uid}/${Date.now()}_${file.name}`);
            const snapshot = await uploadBytes(fileRef, file);
            return await getDownloadURL(snapshot.ref);
        } catch (error) {
            console.error("Firebase Storage upload error:", error);
            showNotification(`Media upload failed: ${error.message}`);
            return null;
        }
    }

    // Handle Post Like/Unlike
    async function handleLike(postId, button) {
        if (!db || !currentUser) {
            showNotification("Please log in to like posts.");
            return;
        }
        const postRef = doc(db, "social", postId);
        const likeRef = doc(postRef, "likes", currentUser.uid);
        const isCurrentlyLiked = userLikes[postId] === true; // Use cached value

        // Optimistic UI update
        const originalLikeState = userLikes[postId];
        const postData = postsDataGlobal[postId];
        const originalLikeCount = postData?.likeCount || 0;

        userLikes[postId] = !isCurrentlyLiked;
        if (postData) {
            postData.likeCount = originalLikeCount + (userLikes[postId] ? 1 : -1);
        }
        updateLikeButtonUI(postId, userLikes[postId]); // Update UI immediately

        button.disabled = true; // Disable button during transaction

        try {
            await runTransaction(db, async (transaction) => {
                const postDoc = await transaction.get(postRef);
                if (!postDoc.exists()) throw "Document does not exist!";

                let currentDbLikeCount = postDoc.data().likeCount || 0;
                const likeDoc = await transaction.get(likeRef); // Check if like actually exists in DB

                if (!isCurrentlyLiked && !likeDoc.exists()) { // Liking
                    transaction.set(likeRef, { createdAt: serverTimestamp() });
                    transaction.update(postRef, { likeCount: currentDbLikeCount + 1 });
                } else if (isCurrentlyLiked && likeDoc.exists()) { // Unliking
                    transaction.delete(likeRef);
                    transaction.update(postRef, { likeCount: Math.max(0, currentDbLikeCount - 1) });
                } else {
                    // State mismatch (UI was wrong or race condition), log and maybe revert UI
                    console.warn(`Like state mismatch for post ${postId}. UI: ${isCurrentlyLiked}, DB: ${likeDoc.exists()}`);
                    // Revert optimistic update if mismatch detected
                    userLikes[postId] = likeDoc.exists();
                     if (postData) postData.likeCount = currentDbLikeCount;
                    // No transaction update needed here as we are aborting the intended action
                    throw new Error("Like state mismatch detected.");
                }
            });

            // Transaction successful - UI already updated optimistically
            // Optional: Notify post owner on like (if not self)
             const likedPostData = postsDataGlobal[postId];
             if (!isCurrentlyLiked && likedPostData && likedPostData.authorId !== currentUser.uid) {
                // Send notification logic here (e.g., Firestore function)
                 console.log(`User ${currentUser.uid} liked post ${postId} by ${likedPostData.authorId}`);
                 // showNotification("Liked post!"); // Or maybe not notify self
             }


        } catch (error) {
            console.error("Like transaction failed:", error);
            showNotification(`Could not ${isCurrentlyLiked ? 'unlike' : 'like'} post. ${error.message}`);
            // Revert optimistic UI update on failure
            userLikes[postId] = originalLikeState;
             if (postData) postData.likeCount = originalLikeCount;
            updateLikeButtonUI(postId, userLikes[postId]);
        } finally {
            button.disabled = false; // Re-enable button
        }
    }

    // Handle New Comment Submission
    async function handleCommentSubmit(postId, text, inputField, submitButton) {
        if (!db || !currentUser) {
            showNotification("Please log in to comment.");
            return;
        }
        const postRef = doc(db, "social", postId);
        const commentsRef = collection(postRef, "comments");

        inputField.disabled = true;
        submitButton.disabled = true;
        submitButton.classList.add('disabled');

        const newCommentData = {
            text: text,
            authorId: currentUser.uid,
            authorName: currentUser.displayName || currentUser.email || "Anonymous",
            authorAvatarUrl: currentUser.photoURL || 'assets/images/user.png', // Ensure fallback
            createdAt: serverTimestamp() // Use server timestamp
        };

        try {
            // Add the comment document
            const commentDocRef = await addDoc(commentsRef, newCommentData);

            // Update the post's comment count using a transaction
            await runTransaction(db, async (transaction) => {
                const postDoc = await transaction.get(postRef);
                if (!postDoc.exists()) throw "Post document does not exist!";
                const newCommentCount = (postDoc.data().commentCount || 0) + 1;
                transaction.update(postRef, { commentCount: newCommentCount });
                // Update local cache
                if (postsDataGlobal[postId]) postsDataGlobal[postId].commentCount = newCommentCount;
            });

            // Clear input field
            inputField.value = "";

            // Add comment to UI immediately (Optimistic Update Part 2)
            const commentsList = postList.querySelector(`.comments-section[data-post-id="${postId}"] .comments-list`);
            if (commentsList) {
                 // Need to simulate the serverTimestamp for immediate display
                 const optimisticCommentData = { ...newCommentData, createdAt: { toDate: () => new Date() }}; // Fake timestamp
                 renderComment(optimisticCommentData, commentsList);
                 // Ensure comment section is visible and height adjusted
                 const commentsSection = commentsList.closest('.comments-section');
                 if (commentsSection && !commentsSection.classList.contains('visible')) {
                    toggleComments(postId, commentsSection); // Open if closed
                 } else if (commentsSection) {
                     // If already open, just adjust height
                     commentsSection.style.maxHeight = commentsList.scrollHeight + 'px';
                 }
            }

            // Update the comment count display in the post stats
            updateCommentCountUI(postId);

             // Optional: Notify post owner on comment (if not self)
             const commentedPostData = postsDataGlobal[postId];
             if (commentedPostData && commentedPostData.authorId !== currentUser.uid) {
                 console.log(`User ${currentUser.uid} commented on post ${postId} by ${commentedPostData.authorId}`);
                 showNotification("Comment posted!"); // Notify self
             } else {
                 showNotification("Comment posted!");
             }

        } catch (error) {
            console.error("Error adding comment:", error);
            showNotification("Could not post comment. Please try again.");
            // Consider removing the optimistically added comment from UI if needed
        } finally {
            inputField.disabled = false;
            // Keep submit disabled until input changes (handled by input listener)
        }
    }

    // Create New Post
    async function handleCreatePost() {
        if (!db || !currentUser) {
            showNotification("Service unavailable or not logged in.");
            return;
        }
        const descVal = postDescriptionEl.value.trim();
        const mediaFile = postMediaEl.files[0];

        if (!descVal && !mediaFile) {
            showNotification("Please write something or add a photo/video.");
            return;
        }

        submitPostBtn.disabled = true;
        submitPostBtn.textContent = "Posting...";
        loadingOverlay?.classList.add("active"); // Show loading overlay

        let mediaUrl = "";
        let mediaType = "";

        if (mediaFile) {
            mediaUrl = await uploadMediaToFirebase(mediaFile, 'posts'); // Use helper
            if (!mediaUrl) {
                // Error handled in uploadMediaToFirebase
                loadingOverlay?.classList.remove("active");
                submitPostBtn.disabled = false;
                submitPostBtn.textContent = "Post";
                return; // Stop if upload failed
            }
            mediaType = mediaFile.type.startsWith("video") ? "video" : "image";
        }

        try {
            const authorName = currentUser.displayName || currentUser.email || "Anonymous";
            const authorAvatar = currentUser.photoURL || 'assets/images/user.png'; // Fallback

            await addDoc(collection(db, "social"), {
                description: descVal,
                mediaUrl: mediaUrl,
                mediaType: mediaType,
                author: authorName,
                authorId: currentUser.uid,
                authorAvatarUrl: authorAvatar,
                createdAt: serverTimestamp(),
                likeCount: 0,
                commentCount: 0
            });

            // Reset form and close modal
            if (postDescriptionEl) postDescriptionEl.value = "";
            if (postMediaEl) postMediaEl.value = ""; // Reset file input
            newPostModal?.classList.remove("active");
            showNotification("Post created successfully!");
            loadPosts(); // Reload posts to show the new one at the top
        } catch (error) {
            console.error("Error creating post:", error);
            showNotification(`Failed to create post: ${error.message}`);
        } finally {
            // Ensure loading overlay is hidden and button is reset
            loadingOverlay?.classList.remove("active");
            submitPostBtn.disabled = false;
            submitPostBtn.textContent = "Post";
        }
    }

     // Edit Post (Open Modal)
     window.editPost = (postId) => { // Make globally accessible
         if (!currentUser) return; // Should not happen if button is visible
         editPostId = postId;
         const postData = postsDataGlobal[postId];
         if (postData && postData.authorId === currentUser.uid) {
             editPostDescriptionEl.value = postData.description || "";
             editPostModal.classList.add("active");
         } else {
             console.error("Cannot edit post: Not author or post data missing.");
             showNotification("Could not edit post.");
         }
     };

     // Update Post (Submit Edit)
     async function handleUpdatePost() {
         if (!editPostId || !currentUser || !db) return;
         const postData = postsDataGlobal[editPostId];
         if (!postData || postData.authorId !== currentUser.uid) {
             showNotification("Error: Cannot update this post.");
             return;
         }

         updatePostBtn.disabled = true;
         updatePostBtn.textContent = "Updating...";

         try {
             await updateDoc(doc(db, "social", editPostId), {
                 description: editPostDescriptionEl.value.trim(),
                 updatedAt: serverTimestamp() // Add an updated timestamp
             });
             showNotification("Post updated successfully.");
             editPostModal.classList.remove("active");
             // Update local cache and UI without full reload
             postsDataGlobal[editPostId].description = editPostDescriptionEl.value.trim();
             const postCard = postList.querySelector(`.post-card[data-post-id="${editPostId}"]`);
             if (postCard) {
                 const contentEl = postCard.querySelector('.post-content');
                 if (contentEl) {
                     contentEl.innerHTML = formatPostContent(editPostDescriptionEl.value.trim());
                 }
             }
             editPostId = null; // Reset edit state
         } catch (error) {
             console.error("Error updating post:", error);
             showNotification("Could not update post.");
         } finally {
             updatePostBtn.disabled = false;
             updatePostBtn.textContent = "Update";
         }
     }

     // Delete Post
     window.deletePost = async (postId) => { // Make globally accessible
        if (!currentUser) return; // Should not happen
        const postData = postsDataGlobal[postId];
         if (!postData || postData.authorId !== currentUser.uid) {
             showNotification("Error: Cannot delete this post.");
             return;
         }

        if (confirm("Are you sure you want to delete this post? This cannot be undone.")) {
             // Optionally show loading state on the specific post card
            const postCard = postList.querySelector(`.post-card[data-post-id="${postId}"]`);
            if (postCard) postCard.style.opacity = '0.5';

            try {
                await deleteDoc(doc(db, "social", postId));
                showNotification("Post deleted successfully.");
                // Remove post from UI immediately
                if (postCard) postCard.remove();
                delete postsDataGlobal[postId]; // Remove from cache
                // Check if feed is now empty
                if (postList && postList.children.length === 0) {
                    showEmptyState();
                }
            } catch (error) {
                console.error("Error deleting post:", error);
                showNotification("Could not delete post.");
                 if (postCard) postCard.style.opacity = '1'; // Restore opacity on error
            }
        }
     };

    // --- UI Update Functions ---

    // Update Like Button and Count Display
    function updateLikeButtonUI(postId, isLiked) {
        const postCards = postList?.querySelectorAll(`.post-card[data-post-id="${postId}"]`);
        postCards?.forEach(postCard => {
            const likeButton = postCard.querySelector('.like-button');
            const icon = likeButton?.querySelector('.material-icons, .material-icons-outlined');
            const likeCountSpan = postCard.querySelector('.post-stats .likes-count');

            // Update button appearance
            if (likeButton && icon) {
                likeButton.classList.toggle('liked', isLiked);
                icon.textContent = isLiked ? 'thumb_up' : 'thumb_up_off_alt';
                icon.className = isLiked ? 'material-icons' : 'material-icons-outlined';
            }

            // Update count display using cached data
            const count = postsDataGlobal[postId]?.likeCount || 0;
             if (likeCountSpan) {
                 const likeIconHtml = `<span class="material-icons like-icon-filled" style="font-size: 0.9rem; vertical-align: middle; margin-right: 2px;">thumb_up</span>`;
                 likeCountSpan.innerHTML = count > 0 ? `${likeIconHtml} ${count}` : '';
             }
        });
    }

    // Update Comment Count Display
    function updateCommentCountUI(postId) {
        const postCards = postList?.querySelectorAll(`.post-card[data-post-id="${postId}"]`);
        postCards?.forEach(postCard => {
            const commentCountSpan = postCard.querySelector('.post-stats .comments-count');
             if (!commentCountSpan) return;

            // Use cached data
             const count = postsDataGlobal[postId]?.commentCount || 0;
             commentCountSpan.textContent = count > 0 ? `${count} Comment${count > 1 ? 's' : ''}` : '';
        });
    }


    // --- Event Listeners ---

    // Authentication State Change
    onAuthStateChanged(auth, async (user) => {
      loadingOverlay?.classList.add('active'); // Show loading on auth change
      if (user) {
        currentUser = user;
        console.log("User logged in:", currentUser.uid);
        updateHeaderAvatars(user); // Update avatars everywhere
        await loadConnects(); // Load connects (stories)
        await loadPosts(); // Load posts (fetches likes inside)
        // listenForNotifications(); // Optional: Real-time notifications
      } else {
        currentUser = null;
        userLikes = {}; // Clear likes cache
        postsDataGlobal = {}; // Clear post cache
        console.log("User logged out or not authenticated.");
        updateHeaderAvatars(null); // Set default avatars
        clearConnects(); // Clear dynamic connects
        showEmptyState("Please log in to see the feed."); // Show login prompt
        loadingOverlay?.classList.remove('active'); // Hide loading
      }
      // Loading overlay hidden inside loadPosts or here if logged out
    });

    // Open "New Post" Modal
     function openNewPostModal() {
         if (!currentUser) { showNotification("Please log in to create a post."); return; }
         // Reset form fields
         postDescriptionEl.value = "";
         postMediaEl.value = "";
         newPostModal?.classList.add("active");
     }
    showNewPostModalBtn?.addEventListener("click", openNewPostModal);
    showNewPostModalPhotoBtn?.addEventListener("click", () => {
        openNewPostModal();
        // Optional: Trigger file input click after modal opens slightly delayed
        // setTimeout(() => postMediaEl?.click(), 100);
    });


    // Close Modals
    modalClose?.addEventListener("click", () => newPostModal?.classList.remove("active"));
    editModalClose?.addEventListener("click", () => {
        editPostModal.classList.remove("active");
        editPostId = null; // Reset edit state on close
    });

    // Submit New Post
    submitPostBtn?.addEventListener("click", handleCreatePost);

    // Update Edited Post
    updatePostBtn?.addEventListener('click', handleUpdatePost);

    // Open File Input for Connects
    createConnectCard?.addEventListener('click', () => {
      if (!currentUser) { showNotification("Please log in to create a connect."); return; }
      connectFileInput?.click();
    });

    // Handle Connect File Selection
    connectFileInput?.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (file) {
          createConnect(file);
      }
    });

    // Event Delegation for Likes and Comment Submit within Post List
    postList?.addEventListener('click', (e) => {
      // Like Button Click
      const likeButton = e.target.closest('.like-button');
      if (likeButton) {
        const postId = likeButton.dataset.postId;
        handleLike(postId, likeButton); // Pass button for disabling
      }

      // Comment Submit Button Click
      const submitButton = e.target.closest('.comment-submit-btn');
      if (submitButton && !submitButton.classList.contains('disabled')) {
        if (!currentUser) { showNotification("Please log in to comment."); return; }
        const postId = submitButton.dataset.postId;
        const postCard = submitButton.closest('.post-card');
        const inputField = postCard?.querySelector(`.comment-input[data-post-id="${postId}"]`);
        if (inputField) {
          const commentText = inputField.value.trim();
          if (commentText) {
            handleCommentSubmit(postId, commentText, inputField, submitButton);
          }
        }
      }
    });

    // Enable/Disable Comment Submit Button based on Input
    postList?.addEventListener('input', (e) => {
      const inputField = e.target.closest('.comment-input');
      if (inputField) {
        const postId = inputField.dataset.postId;
        const postCard = inputField.closest('.post-card');
        const submitButton = postCard?.querySelector(`.comment-submit-btn[data-post-id="${postId}"]`);
        if (submitButton) {
          const hasText = inputField.value.trim().length > 0;
          submitButton.classList.toggle('disabled', !hasText);
           submitButton.disabled = !hasText; // Also toggle disabled property
        }
      }
    });

    // Placeholder for Messenger Icon Click
    window.handleMessageClick = () => { // Make globally accessible
        if (!currentUser) { showNotification("Please log in to view messages."); return; }
        // Navigate to messages page or open chat UI
        window.location.href = "messages.html"; // Example navigation
        // showNotification("Messenger feature coming soon!");
    }

    // Optional: Close modal if overlay is clicked
    newPostModal?.addEventListener('click', (e) => {
        if (e.target === newPostModal) { // Check if the click was directly on the overlay
            newPostModal.classList.remove('active');
        }
    });
    editPostModal?.addEventListener('click', (e) => {
        if (e.target === editPostModal) {
            editPostModal.classList.remove('active');
            editPostId = null;
        }
    });

    // --- Initial Load ---
    // Auth listener handles initial load

  </script>
</body>
</html>